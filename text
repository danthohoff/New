from typing import Iterable, Sequence, Mapping, Set, Optional

def build_per_day(
    tage: Iterable,
    join_tables: Sequence[Optional[pl.DataFrame]],
    *,
    phases: Sequence[str],
    categories: Sequence[str],
    on: str = "Betriebstag",
    group_map: Optional[Mapping[str, Set[str]]] = None,  # z.B. {"EIU LU": {"Bau","Anlagen",...}, ...}
) -> pl.DataFrame:
    """
    Baut 'per_day' ohne Hardcoding der Spaltenlisten:
      - joint alle Tabellen auf `on`
      - füllt numerische Nulls
      - berechnet:
          • Basissummen ("Züge alle", "Halte alle", "pü Halte alle")
          • Kategorie-Summen: "{Kategorie} LU alle"
          • Gruppen je Phase/andere: "{Gruppe} Auswahl {phase}", "{Gruppe} andere"
          • Gruppen 'alle' und Gesamt "LU alle"
      - hängt ISO-KW an und sortiert absteigend nach `on`
    """

    # Default-Gruppierung nur, wenn keine mitgegeben wird (minimaler „Hardcode“):
    if group_map is None:
        group_map = {
            "EIU LU": {"Bau", "Anlagen", "Betrieb_und_Fahrplan", "Sonstige_EIU"},
            "EVU LU": {"Fahrzeuge", "Personal", "Haltezeitüberschreitung", "Sonstige_EVU", "Bereitstellung_und_Betrieb"},
            "Sek LU": {"Zugfolge", "Umlauf_Anschluss_Flügeln"},
            "Weitere LU": {"Extern", "Sonstige_Weitere"},
        }

    sel_suffixes = [f"Auswahl {p}" for p in phases]
    all_suffixes = sel_suffixes + ["andere"]

    def lu_col(cat: str, suffix: str) -> str:
        # Einheitliche Benennung an einer Stelle:
        return f"{cat} LU {suffix}"

    # DataFrame aufbauen und joinen
    df = pl.DataFrame({on: list(tage)})
    for t in join_tables:
        if t is not None:
            df = df.join(t, on=on, how="left")

    # numerische Nulls -> 0
    df = df.with_columns(pl.col(pl.NUMERIC_DTYPES).fill_null(0))

    # Helper: sichere horizontale Summe nur über vorhandene Spalten
    def safe_hsum(cols: Sequence[str], alias: str, cast=pl.Int64) -> pl.Expr:
        present = [pl.col(c).fill_null(0) for c in cols if c in df.columns]
        expr = pl.sum_horizontal(present) if present else pl.lit(0)
        return expr.cast(cast).alias(alias)

    exprs = []

    # --- Basissummen (minimal „hart“, aber per Muster generiert) ---------------
    base_specs = {
        "Züge alle": ["Züge Auswahl", "Züge andere"],
        "Halte alle": [*(f"Halte Auswahl {p}" for p in phases), "Halte andere"],
        "pü Halte alle": [*(f"pü Halte Auswahl {p}" for p in phases), "pü Halte andere"],
    }
    exprs.extend(safe_hsum(cols, alias) for alias, cols in base_specs.items())

    # --- Kategorie-Summen: "{Kategorie} LU alle" -------------------------------
    for cat in categories:
        exprs.append(safe_hsum([lu_col(cat, s) for s in all_suffixes], f"{cat} LU alle"))

    # --- Gruppen je Phase+andere und Gruppen-„alle“ ---------------------------
    for group_name, cats in group_map.items():
        # je Phase/andere
        for sfx in all_suffixes:
            cols = [lu_col(cat, sfx) for cat in cats]
            exprs.append(safe_hsum(cols, f"{group_name} {sfx}"))
        # „alle“
        exprs.append(
            safe_hsum([lu_col(cat, s) for cat in cats for s in all_suffixes], f"{group_name} alle")
        )

    # --- Gesamt "LU alle" (direkt aus den Basis-LU-Spalten, keine Zwischenabhängigkeit)
    exprs.append(
        safe_hsum([lu_col(cat, s) for cat in categories for s in all_suffixes], "LU alle")
    )

    # alles auf einmal berechnen, KW anhängen, sortieren
    df = (df
          .with_columns(exprs)
          .with_columns(pl.col(on).dt.week().alias("KW"))
          .sort(on, descending=True))

    return df

per_day = build_per_day(
    tage=tage,
    join_tables=[zuege_auswahl_t, zuege_andere_t, halte_sel, andere_t, lu_sel_day, lu_andere_day],
    phases=phases,
    categories=categories,
    # group_map optional – wenn du eine andere Zuordnung brauchst:
    # group_map={"EIU LU": {"Bau","Anlagen",...}, "EVU LU": {...}, "Sek LU": {...}, "Weitere LU": {...}}
)
