import polars as pl

# --- Helper: UC in Kategorien mappen --------------------
def uc_category_expr():
    return (
        pl.when(pl.col("uc").is_in([31, 32, 28, 21, 22, 23, 24, 25, 26, 27, 29, 30, 18, 12, 13, 14, 47, 48, 49]))
          .then(pl.lit("EIU"))
        .when(pl.col("uc").is_in([62, 63, 64, 69, 58, 68, 51, 52, 53, 54, 57, 61, 59, 60]))
          .then(pl.lit("EVU"))
        .when(pl.col("uc").is_in([91, 92, 93, 94, 95]))
          .then(pl.lit("Sek"))
        .when(pl.col("uc").is_in([6, 7, 40, 41, 70, 71, 80, 81, 82, 83, 84, 85, 90, 8, 2, 19, 46, 96]))
          .then(pl.lit("Weitere"))
        .otherwise(pl.lit("Weitere"))  # statt "Unbekannt"
    )

# --- Helper: Transitions mit Forward/Backward-Fill -------
def build_transitions_with_net_ff(zlm: pl.DataFrame, seg_edges: pl.DataFrame) -> pl.DataFrame:
    """
    Liefert pro befahrenem Abschnitt (prev_bst -> bst) den Netztyp (HLN/Flaeche),
    forward/backward gefüllt innerhalb jedes Zuglaufs.
    """
    # 1) prev_bst bestimmen
    base = (
        zlm.sort(["Betriebstag", "zn", "istzeit_dt"])
           .with_columns(
               pl.col("bst").shift(1).over(["Betriebstag", "zn"]).alias("prev_bst")
           )
           .filter(pl.col("prev_bst").is_not_null())
           .select(["Betriebstag", "zn", "istzeit_dt", "prev_bst", "bst"])
    )

    # 2) Netz zuordnen
    trans = (
        base.join(seg_edges, left_on=["prev_bst", "bst"], right_on=["u", "v"], how="left")
            .rename({"netz": "netz_raw"})
            .select(["Betriebstag", "zn", "istzeit_dt", "prev_bst", "bst", "netz_raw"])
    )

    # 3) Forward-/Backward-Fill je Zuglauf
    trans_filled = (
        trans.group_by(["Betriebstag", "zn"]).map_groups(
            lambda g: g.sort("istzeit_dt").with_columns(
                g["netz_raw"]
                  .fill_null(strategy="forward")
                  .fill_null(strategy="backward")
                  .fill_null("Flaeche")  # letzte Sicherheit
                  .alias("netz_final")
            )
        )
    )
    return trans_filled

# --- Hauptfunktion ---------------------------------------
def metrics_per_day_with_net(zlm: pl.DataFrame, seg_edges: pl.DataFrame) -> pl.DataFrame:
    """
    Berechnet Tagesmetriken nach Netztyp HLN/Flaeche:
      - Halte, pünktliche Halte
      - LU gesamt und je UC-Kategorie
    """

    # Transitions bauen
    transitions = build_transitions_with_net_ff(zlm, seg_edges)

    # --- Halte ---
    halte_labeled = (
        zlm.filter(pl.col("fsStatus").is_in([1, 3]))
           .join(
               transitions.select(["Betriebstag", "zn", "bst", "netz_final"]),
               on=["Betriebstag", "zn", "bst"],
               how="left"
           )
           .with_columns([
               pl.col("netz_final").fill_null("Flaeche"),
               (pl.col("vsp") < 360).alias("puenktlich"),
           ])
    )
    halte_per_day = (
        halte_labeled.group_by(["Betriebstag", "netz_final"])
                     .agg([
                         pl.count().alias("Halte"),
                         pl.sum("puenktlich").alias("pü Halte")
                     ])
    )

    # --- LU ---
    lu_labeled = (
        zlm.filter(pl.col("uc").is_not_null())
           .join(
               transitions.select(["Betriebstag", "zn", "bst", "netz_final"]),
               on=["Betriebstag", "zn", "bst"],
               how="left"
           )
           .with_columns([
               pl.col("netz_final").fill_null("Flaeche"),
               uc_category_expr().alias("uc_cat"),
           ])
    )
    lu_per_day = (
        lu_labeled.group_by(["Betriebstag", "netz_final", "uc_cat"])
                  .agg(pl.count().alias("LU"))
                  .pivot(index=["Betriebstag","netz_final"],
                         columns="uc_cat", values="LU")
                  .fill_null(0)
    )

    # --- Merge Halte & LU ---
    per_day = halte_per_day.join(lu_per_day, on=["Betriebstag","netz_final"], how="outer").fill_null(0)

    return per_day