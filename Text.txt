import polars as pl
from pathlib import Path

def load_network_segmentation(csv_path: str | Path) -> pl.DataFrame:
    """
    CSV-Spalten: 'VonBetriebsstelle','BisBetriebsstelle','Segmentierung2025'
    Rückgabe (gerichtet, beide Richtungen):
      u, v, netz  (netz ∈ {'HLN','Flaeche'})
    """
    seg = (pl.read_csv(csv_path)
             .select(["VonBetriebsstelle", "BisBetriebsstelle", "Segmentierung2025"])
             .with_columns([
                 pl.col("VonBetriebsstelle").cast(pl.Utf8).alias("von"),
                 pl.col("BisBetriebsstelle").cast(pl.Utf8).alias("bis"),
                 pl.col("Segmentierung2025").cast(pl.Utf8).str.to_uppercase().alias("seg_raw"),
             ])
             .with_columns(
                 pl.when(pl.col("seg_raw") == "HLN").then(pl.lit("HLN"))
                  .otherwise(pl.lit("Flaeche")).alias("netz")
             ))

    fwd = seg.select([pl.col("von").alias("u"), pl.col("bis").alias("v"), pl.col("netz")])
    rev = seg.select([pl.col("bis").alias("u"), pl.col("von").alias("v"), pl.col("netz")])
    return pl.concat([fwd, rev]).unique(subset=["u", "v"])


def label_transitions_with_net(df_ev: pl.DataFrame, seg_edges: pl.DataFrame) -> pl.DataFrame:
    """
    df_ev: ZLM-Events mit Spalten ['Betriebstag','zn','bst','istzeit_dt'] (plus uc/fsStatus egal)
    seg_edges: aus load_network_segmentation()
    Rückgabe: pro befahrener Kante ein Intervall:
      Betriebstag, zn, prev_bst, bst, prev_t, istzeit_dt, netz
    """
    trans = (
        df_ev.sort(["Betriebstag","zn","istzeit_dt"])
             .with_columns([
                 pl.col("bst").shift(1).over(["Betriebstag","zn"]).alias("prev_bst"),
                 pl.col("istzeit_dt").shift(1).over(["Betriebstag","zn"]).alias("prev_t"),
             ])
             .filter(pl.col("prev_bst").is_not_null())
             .select(["Betriebstag","zn","prev_bst","bst","prev_t","istzeit_dt"])
    )
    trans = (
        trans.join(seg_edges, left_on=["prev_bst","bst"], right_on=["u","v"], how="left")
             .with_columns(pl.col("netz").fill_null("Flaeche"))  # oder 'Unbekannt' – je nach Wunsch
             .drop(["u","v"])
    )
    return trans


def lu_hln_flaeche_per_day(df_ev: pl.DataFrame, trans_net: pl.DataFrame) -> pl.DataFrame:
    """
    df_ev: ZLM-Events (braucht 'uc' Spalte)
    trans_net: von label_transitions_with_net()
    Ergebnis: pro Tag Spalten 'LU HLN', 'LU Fläche', 'LU alle'
    """
    # alle LU-Ereignisse (Zeit & Zug)
    df_lu = (
        df_ev.filter(pl.col("uc").is_not_null())
             .select(["Betriebstag","zn","istzeit_dt","uc"])
             .sort(["Betriebstag","zn","istzeit_dt"])
    )
    if df_lu.is_empty():
        return (df_ev.select("Betriebstag").unique().sort("Betriebstag")
                    .with_columns([pl.lit(0).alias("LU HLN"), pl.lit(0).alias("LU Fläche"), pl.lit(0).alias("LU alle")]))

    # asof: nächstes Kanten-Ende >= LU-Zeit je (Tag, Zug)
    trans_sorted = trans_net.sort(["Betriebstag","zn","istzeit_dt"])
    lu_mapped = (
        df_lu.join_asof(trans_sorted,
                        left_on="istzeit_dt", right_on="istzeit_dt",
                        by=["Betriebstag","zn"], strategy="forward")
             # nur wenn LU-Zeit im Intervall (prev_t, istzeit_dt] liegt
             .filter(pl.col("prev_t").is_not_null() & (pl.col("istzeit_dt") > pl.col("prev_t")))
             .select(["Betriebstag","zn","istzeit_dt","uc","netz"])
    )

    # Tages-Pivot HLN vs Fläche
    per_day = (
        lu_mapped.group_by(["Betriebstag","netz"]).agg(pl.len().alias("n"))
                 .pivot(values="n", index="Betriebstag", columns="netz")
    )
    for col, name in [("HLN","LU HLN"), ("Flaeche","LU Fläche")]:
        if col not in per_day.columns:
            per_day = per_day.with_columns(pl.lit(0).alias(col))
        per_day = per_day.rename({col: name})

    per_day = per_day.with_columns((pl.col("LU HLN") + pl.col("LU Fläche")).alias("LU alle")) \
                     .sort("Betriebstag")
    return per_day


# 0) ZLM laden (deine Funktion)
# df_ev: Spalten mind. ['Betriebstag','zn','bst','istzeit_dt','uc','fsStatus','vsp']

# 1) Netz-Segmentierung laden
seg_edges = load_network_segmentation("/pfad/segmentierung.csv")

# 2) Transitionen labeln
trans_net = label_transitions_with_net(df_ev, seg_edges)

# 3) LU HLN/Fläche pro Tag (ALLE Züge)
per_day_lu_net = lu_hln_flaeche_per_day(df_ev, trans_net)
per_day_lu_net.write_csv("/pfad/cache/lu_hln_flaeche.csv")

print(per_day_lu_net)


per_day_all = daily_metrics_simple(df_ev, df_ev.select(["Betriebstag","zn"]).unique())
per_day_all = per_day_all.join(per_day_lu_net, on="Betriebstag", how="left") \
                         .with_columns([
                             pl.col("LU HLN").fill_null(0),
                             pl.col("LU Fläche").fill_null(0),
                             pl.col("LU alle").fill_null(0),
                         ])