import polars as pl

def _ensure_uv_net(seg_edges: pl.DataFrame) -> pl.DataFrame:
    """Bringt eine Segmentierungs-Tabelle sicher auf Spalten u,v,netz (Utf8)."""
    cols = set(seg_edges.columns)
    if not {"u", "v"}.issubset(cols):
        # Versuche typische Varianten zu erkennen
        rename_map = {}
        for cand in ("VonBetriebsstelle", "von_bst", "von bst", "von"):
            if cand in cols: rename_map[cand] = "u"; break
        for cand in ("BisBetriebsstelle", "bis_bst", "bis bst", "bis"):
            if cand in cols: rename_map[cand] = "v"; break
        for cand in ("Segmentierung2025", "netz", "SEGMENT", "segment"):
            if cand in cols: rename_map[cand] = "netz"; break
        if not rename_map.get(next(iter(rename_map), None)):
            # Wenn immer noch nichts passt, Fehlermeldung mit vorhandenen Spalten
            raise ValueError(f"seg_edges hat keine u/v-Spalten. Vorhanden: {seg_edges.columns}")
        seg_edges = seg_edges.rename(rename_map)

    # nur benötigte Spalten behalten und typisieren
    keep = [c for c in ("u", "v", "netz") if c in seg_edges.columns]
    seg_edges = (
        seg_edges.select(keep)
                 .with_columns([
                     pl.col("u").cast(pl.Utf8),
                     pl.col("v").cast(pl.Utf8),
                     pl.col("netz").cast(pl.Utf8),
                 ])
                 .unique(subset=["u","v"])  # Eindeutigkeit pro Kante sicherstellen
    )
    return seg_edges

def _ensure_uv_left(df: pl.DataFrame) -> pl.DataFrame:
    """Sichert, dass linke Tabelle u,v als Utf8 hat (aus prev_bst/bst)."""
    df = df.with_columns([
        pl.col("prev_bst").cast(pl.Utf8),
        pl.col("bst").cast(pl.Utf8),
    ])
    return df.rename({"prev_bst":"u", "bst":"v"})


def lu_hln_flaeche_per_day_node_based(
    df_ev: pl.DataFrame,
    seg_edges: pl.DataFrame,
    *,
    default_to_flaeche: bool = True,
    dedup_key: tuple[str, ...] = ("Betriebstag", "zn", "istzeit_dt", "uc"),
) -> pl.DataFrame:
    # 0) klassische LU-Zählung (zum Abgleich)
    classic = (
        df_ev.filter(pl.col("uc").is_not_null())
             .select(["Betriebstag","zn","istzeit_dt","uc"])
             .unique(subset=list(dedup_key))
             .group_by("Betriebstag").agg(pl.len().alias("LU klassisch"))
    )

    # 1) Events sortieren & prev_bst berechnen
    ev_sorted = (
        df_ev.sort(["Betriebstag","zn","istzeit_dt"])
             .with_columns(pl.col("bst").shift(1).over(["Betriebstag","zn"]).alias("prev_bst"))
    )

    # 2) LU-Zeilen dedupliziert
    lu_rows = (
        ev_sorted.filter(pl.col("uc").is_not_null())
                 .select(["Betriebstag","zn","istzeit_dt","uc","bst","prev_bst"])
                 .unique(subset=list(dedup_key))
    )

    # 3) prev_bst darf nicht null sein
    lu_rows_valid = lu_rows.filter(pl.col("prev_bst").is_not_null())

    # 4) Spalten sicherstellen: linke Seite u/v, rechte Seite u/v/netz
    left_uv = _ensure_uv_left(lu_rows_valid)
    seg_uv  = _ensure_uv_net(seg_edges)

    # 5) Join auf Kante (u,v) → Netzlabel
    lu_labeled = (
        left_uv.join(seg_uv, on=["u","v"], how="left")
               .with_columns(
                    pl.when(pl.col("netz").is_null())
                      .then(pl.lit("Flaeche") if default_to_flaeche else pl.lit("Unbekannt"))
                      .otherwise(pl.col("netz")).alias("netz_final")
               )
               .select(["Betriebstag","zn","istzeit_dt","uc","netz_final"])
               .unique(subset=list(dedup_key))   # gegen evtl. Join-Duplikate absichern
    )

    # 6) Tagesweise zählen
    per_day = (
        lu_labeled.group_by(["Betriebstag","netz_final"])
                  .agg(pl.len().alias("n"))
                  .pivot(values="n", index="Betriebstag", columns="netz_final")
    )
    for k in ["HLN","Flaeche","Unbekannt"]:
        if k not in per_day.columns:
            per_day = per_day.with_columns(pl.lit(0).alias(k))

    per_day = (
        per_day.rename({"HLN":"LU HLN", "Flaeche":"LU Fläche", "Unbekannt":"LU Unbekannt"})
               .with_columns((pl.col("LU HLN")+pl.col("LU Fläche")+pl.col("LU Unbekannt")).alias("LU alle"))
               .sort("Betriebstag")
    )

    # 7) Abgleich
    per_day = per_day.join(classic, on="Betriebstag", how="left").with_columns(pl.col("LU klassisch").fill_null(0))
    return per_day