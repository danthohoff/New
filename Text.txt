# pip install pandas geopandas shapely requests pyproj rtree

from __future__ import annotations
import os
import re
import io
import requests
import pandas as pd
import geopandas as gpd
from shapely.geometry import Point

# ---------- Konfiguration ----------
INPUT_CSV = "strecken.csv"  # <-- Pfad zu deiner CSV
OUTPUT_CSV = "betriebsstellen_mit_bundesland.csv"
# Du kannst hier optional einen lokalen Pfad zu einem Bundesländer-GeoJSON/Shapefile angeben.
# Wenn die Datei nicht existiert, wird automatisch von der URL geladen:
BUNDESLAENDER_PATH = "bundeslaender.geojson"
BUNDESLAENDER_URL = (
    # Deutschland Bundesländer als GeoJSON (mittlere Auflösung)
    "https://raw.githubusercontent.com/isellsoap/deutschlandGeoJSON/master/2_bundeslaender/3_mittel.geojson"
)

# ---------- Hilfsfunktionen ----------
LAT_RANGE_DE = (47.0, 55.2)
LON_RANGE_DE = (5.5, 15.7)

def looks_like_lat(v: float) -> bool:
    return LAT_RANGE_DE[0] - 1 <= v <= LAT_RANGE_DE[1] + 1  # klein wenig Toleranz

def looks_like_lon(v: float) -> bool:
    return LON_RANGE_DE[0] - 1 <= v <= LON_RANGE_DE[1] + 1

def parse_latlon(val) -> tuple[float, float] | tuple[None, None]:
    """
    Erwartete Eingaben:
      - "52.52, 13.405"  oder  "52.52 13.405"
      - (52.52, 13.405)  oder  [52.52, 13.405]
    Liefert (lat, lon) als float. Versucht, vertauschte Reihenfolge zu erkennen und zu korrigieren.
    """
    if pd.isna(val):
        return (None, None)

    if isinstance(val, (tuple, list)) and len(val) == 2:
        a, b = val[0], val[1]
    else:
        s = str(val).strip()
        # Koordinaten durch Komma oder Leerzeichen getrennt
        parts = re.split(r"[,\s]+", s)
        parts = [p for p in parts if p]  # leere entfernen
        if len(parts) < 2:
            return (None, None)
        try:
            a, b = float(parts[0]), float(parts[1])
        except ValueError:
            return (None, None)

    # Heuristik für vertauschte Reihenfolge (manchmal "lon,lat" statt "lat,lon")
    # Standard ist (lat, lon)
    lat, lon = a, b
    if not looks_like_lat(lat) and looks_like_lat(lon) and looks_like_lon(lat):
        lat, lon = lon, lat

    # Falls völlig außerhalb -> None
    if not (looks_like_lat(lat) and looks_like_lon(lon)):
        return (None, None)

    return (float(lat), float(lon))

def load_bundeslaender(path: str, url: str) -> gpd.GeoDataFrame:
    """
    Lädt Bundesländer-Geometrien. Zuerst lokal, sonst aus URL.
    Ergebnis im CRS EPSG:4326 (WGS84).
    """
    gdf = None

    if os.path.exists(path):
        gdf = gpd.read_file(path)
    else:
        # Download versuchen
        resp = requests.get(url, timeout=30)
        resp.raise_for_status()
        # Direkt aus Bytes lesen
        gdf = gpd.read_file(io.BytesIO(resp.content))
        # optional lokal ablegen
        try:
            gdf.to_file(path, driver="GeoJSON")
        except Exception:
            pass  # Falls Dateisystem schreibgeschützt o.ä., nicht kritisch

    if gdf.crs is None:
        # Häufig bereits in EPSG:4326. Im Zweifel annehmen.
        gdf.set_crs(epsg=4326, inplace=True)
    else:
        gdf = gdf.to_crs(epsg=4326)

    return gdf

def pick_name_column(gdf: gpd.GeoDataFrame) -> str:
    """
    Wählt eine Spalte, die den Landesnamen enthält.
    Unterstützt mehrere gängige Schemas (GEN, NAME, name, NAME_1, Bundesland...).
    """
    candidates = ["GEN", "NAME", "name", "NAME_1", "Bundesland", "lan_name", "land_name"]
    for c in candidates:
        if c in gdf.columns:
            return c
    # Fallback: erste Nicht-Geom-Spalte
    for c in gdf.columns:
        if c != gdf.geometry.name:
            return c
    raise ValueError("Keine sinnvolle Namensspalte in den Bundesland-Daten gefunden.")

def build_betriebsstellen_liste(df: pd.DataFrame) -> pd.DataFrame:
    """
    Wandelt breites Schema (von/bis + Koordinaten) in eine lange Liste von Betriebsstellen um.
    Erwartete Spalten: 'von', 'bis', 'von_latlon', 'bis_latlon'
    Ausgaben-Spalten: 'betriebsstelle', 'lat', 'lon'
    """
    required = {"von", "bis", "von_latlon", "bis_latlon"}
    missing = required - set(df.columns)
    if missing:
        raise ValueError(f"Fehlende Spalten in CSV: {missing}")

    a = df[["von", "von_latlon"]].rename(columns={"von": "betriebsstelle", "von_latlon": "latlon"})
    b = df[["bis", "bis_latlon"]].rename(columns={"bis": "betriebsstelle", "bis_latlon": "latlon"})
    long_df = pd.concat([a, b], ignore_index=True)

    # Koordinaten parsen
    latlons = long_df["latlon"].apply(parse_latlon)
    long_df["lat"] = latlons.apply(lambda t: t[0])
    long_df["lon"] = latlons.apply(lambda t: t[1])

    # Aufräumen
    long_df["betriebsstelle"] = long_df["betriebsstelle"].astype(str).str.strip()
    long_df = long_df.dropna(subset=["betriebsstelle", "lat", "lon"])
    long_df = long_df[long_df["betriebsstelle"] != ""]

    # Falls gleiche Betriebsstelle mit leicht unterschiedlichen Koordinaten mehrfach vorkommt:
    # -> "häufigste" Koordinate wählen (Mode), sonst Mittelwert.
    def pick_coords(grp: pd.DataFrame):
        coords = grp[["lat", "lon"]].round(6)  # Koordinaten leicht runden
        mode = coords.value_counts()
        if not mode.empty:
            lat, lon = mode.index[0]
            return pd.Series({"lat": lat, "lon": lon})
        return pd.Series({"lat": grp["lat"].mean(), "lon": grp["lon"].mean()})

    dedup = long_df.groupby("betriebsstelle", as_index=False).apply(pick_coords)
    dedup.reset_index(drop=True, inplace=True)
    return dedup[["betriebsstelle", "lat", "lon"]]

def assign_bundesland(betriebsstellen_df: pd.DataFrame, laender: gpd.GeoDataFrame) -> pd.DataFrame:
    """
    Weist jeder Betriebsstelle per räumlichem Join ein Bundesland zu.
    Mit Fallbacks für Grenzfälle (Buffer, nächste Geometrie).
    """
    name_col = pick_name_column(laender)

    points = gpd.GeoDataFrame(
        betriebsstellen_df.copy(),
        geometry=[Point(xy) for xy in zip(betriebsstellen_df["lon"], betriebsstellen_df["lat"])],
        crs="EPSG:4326",
    )

    # 1) Standard: within
    joined = gpd.sjoin(points, laender[[name_col, laender.geometry.name]], how="left", predicate="within")
    joined.rename(columns={name_col: "bundesland"}, inplace=True)

    # 2) Fallback: kleiner Buffer und intersects
    missing_idx = joined[joined["bundesland"].isna()].index
    if len(missing_idx) > 0:
        buffered = points.loc[missing_idx].copy()
        buffered["geometry"] = buffered.buffer(1e-5)  # ~1m Puffer (ungefähr, da Grad)
        hit = gpd.sjoin(buffered, laender[[name_col, laender.geometry.name]], how="left", predicate="intersects")
        for i, row in hit.iterrows():
            if pd.isna(joined.loc[i, "bundesland"]) and pd.notna(row[name_col]):
                joined.loc[i, "bundesland"] = row[name_col]

    # 3) Letzter Fallback: nächstgelegenes Bundesland (Distanz-Minimum)
    still_missing_idx = joined[joined["bundesland"].isna()].index
    if len(still_missing_idx) > 0:
        # bei 16 Ländern unkritisch: einfache Distanzberechnung
        laender_no_geom = laender[[name_col, laender.geometry.name]].copy()
        for i in still_missing_idx:
            p = points.loc[i, "geometry"]
            # geringste Distanz nehmen
            dists = laender_no_geom.distance(p)
            nearest_id = dists.idxmin()
            joined.loc[i, "bundesland"] = laender_no_geom.loc[nearest_id, name_col]

    result = pd.DataFrame(joined.drop(columns=["geometry"]))
    # Endgültige Spaltenreihenfolge
    result = result[["betriebsstelle", "lat", "lon", "bundesland"]]
    return result

# ---------- Hauptprogramm ----------
def main(input_csv: str = INPUT_CSV,
         output_csv: str = OUTPUT_CSV,
         bundeslaender_path: str = BUNDESLAENDER_PATH,
         bundeslaender_url: str = BUNDESLAENDER_URL):

    # 1) CSV einlesen
    df = pd.read_csv(input_csv)

    # 2) Betriebsstellenliste erzeugen
    bs_df = build_betriebsstellen_liste(df)

    # 3) Bundesländer-Geometrien laden
    laender = load_bundeslaender(bundeslaender_path, bundeslaender_url)

    # 4) Räumlicher Join
    result = assign_bundesland(bs_df, laender)

    # 5) Ergebnis speichern
    result.sort_values(["bundesland", "betriebsstelle"], inplace=True, na_position="last")
    result.to_csv(output_csv, index=False, encoding="utf-8")

    print(f"Fertig. {len(result)} Betriebsstellen mit Bundesland zugeordnet.")
    print(f"→ Datei: {output_csv}")
    print(result.head(10))

if __name__ == "__main__":
    main()