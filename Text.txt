import geopandas as gpd
import pandas as pd
from shapely import wkt

# ------------------------------------------------------------
# Hilfsfunktion: prüft, ob Geometriespalte Strings (WKT) enthält
def _geom_is_wkt(gdf: gpd.GeoDataFrame) -> bool:
    geom_col = gdf.geometry.name if gdf.geometry.name in gdf.columns else None
    if geom_col is None:
        # kein Geometry-Typ gesetzt -> evtl. heißt die Spalte 'geom'
        if "geom" in gdf.columns and pd.api.types.is_string_dtype(gdf["geom"]):
            return True
        return False
    return pd.api.types.is_string_dtype(gdf[geom_col])

# ------------------------------------------------------------
def load_netzstruktur(path: str, level: str, crs_epsg: int = 25832) -> gpd.GeoDataFrame:
    """
    Liest deine Netzstruktur-Datei (GeoJSON oder JSON-Dump mit WKT),
    interpretiert sie zunächst in EPSG:25832 (UTM32), filtert nach Ebene
    ('Region' / 'Netzbezirk' / 'Netz'), und liefert ein GDF in EPSG:4326
    mit Namensspalte 'label'.
    """
    gdf = gpd.read_file(path)

    # Falls Geometrie als WKT-String vorliegt (z.B. aus JSON-Dump):
    if _geom_is_wkt(gdf):
        # finde die Spalte mit WKT
        geom_col = "geom" if "geom" in gdf.columns else gdf.columns[-1]
        gdf["geometry"] = gdf[geom_col].apply(wkt.loads)
        gdf = gpd.GeoDataFrame(gdf, geometry="geometry", crs=f"EPSG:{crs_epsg}")
    else:
        # wenn bereits echte Geometrien vorhanden sind, aber ohne CRS -> 25832 annehmen
        if gdf.crs is None:
            gdf.set_crs(epsg=crs_epsg, inplace=True)

    # Ebene filtern
    lvl_col = next((c for c in gdf.columns if c.lower() == "org_level_name"), None)
    if not lvl_col:
        raise ValueError("Spalte 'org_level_name' nicht gefunden.")
    name_col = next((c for c in gdf.columns if c.lower() == "org_name"), None)
    if not name_col:
        raise ValueError("Spalte 'org_name' nicht gefunden.")

    target = level.capitalize()  # 'region' -> 'Region', etc.
    gdf = gdf[gdf[lvl_col].astype(str).str.casefold() == target.casefold()].copy()
    if gdf.empty:
        raise ValueError(f"Keine Features mit org_level_name='{target}' in {path}.")

    # sauber benennen & zu WGS84 für den Intersects-Join
    gdf = gdf.rename(columns={name_col: "label"}).to_crs(epsg=4326)
    return gdf[["label", gdf.geometry.name]]

# ------------------------------------------------------------
def clip_bst_to_layer(bst: pd.DataFrame, poly_wgs84: gpd.GeoDataFrame) -> pd.DataFrame:
    """ Intersects in 4326; Nearest-Fallback sauber in 25832. """
    from shapely.geometry import Point

    # Punkte in 4326
    points = gpd.GeoDataFrame(
        bst.copy(),
        geometry=[Point(xy) for xy in zip(bst["lon"], bst["lat"])],
        crs="EPSG:4326"
    )

    # 1) Intersects-Join (meist reicht das)
    joined = gpd.sjoin(points, poly_wgs84[["label", poly_wgs84.geometry.name]],
                       how="left", predicate="intersects").rename(columns={"label": "gebiet"})

    # 2) Fallback: nächste Fläche – aber in metrischem CRS (25832)
    missing = joined["gebiet"].isna()
    if missing.any():
        pts_32 = points.to_crs(epsg=25832)
        poly_32 = poly_wgs84.to_crs(epsg=25832)

        # sjoin_nearest ist vektorisiert & robust
        nearest = gpd.sjoin_nearest(
            pts_32.loc[missing, ["geometry"]],
            poly_32[["label", poly_32.geometry.name]],
            how="left",
            distance_col="dist_m"
        )
        # Namen zurückschreiben
        for idx, row in nearest.reset_index().itertuples(index=False):
            joined.at[idx, "gebiet"] = row.label

    out = pd.DataFrame(joined.drop(columns=["geometry"]))
    return out[["betriebsstelle", "lat", "lon", "gebiet"]]