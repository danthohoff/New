import polars as pl

def lu_hln_flaeche_per_day_stable(df_ev: pl.DataFrame, trans_net: pl.DataFrame) -> pl.DataFrame:
    """
    df_ev: ZLM-Events (mind. Betriebstag:Date, zn:Utf8, istzeit_dt:Datetime, uc:Int64|Null)
    trans_net: aus label_transitions_with_net(...)  mit Spalten
               ['Betriebstag','zn','prev_bst','bst','prev_t','istzeit_dt','netz']
               (istzeit_dt = Transition-Ende der Folgestation)
    Ergebnis: pro Tag Spalten 'LU HLN', 'LU Fläche', 'LU alle'
    """
    # 1) LU-Events extrahieren
    df_lu = (
        df_ev
        .filter(pl.col("uc").is_not_null())
        .select(["Betriebstag", "zn", "istzeit_dt", "uc"])
    )

    if df_lu.is_empty():
        return (
            df_ev.select("Betriebstag").unique().sort("Betriebstag")
                 .with_columns([
                     pl.lit(0).alias("LU HLN"),
                     pl.lit(0).alias("LU Fläche"),
                     pl.lit(0).alias("LU alle"),
                 ])
        )

    # 2) Transitionen: rechtes Intervallende klar benennen
    trans_g = (
        trans_net
        .rename({"istzeit_dt": "end_t"})
        .select(["Betriebstag", "zn", "prev_t", "end_t", "netz"])
    )

    # 3) Gruppenweiser Key-Join (Betriebstag, zn), danach Intervall-Filter:
    #    prev_t  <  LU_time  <= end_t   → LU liegt auf dieser Kante
    cand = (
        df_lu
        .join(trans_g, on=["Betriebstag", "zn"], how="inner")
        .filter(
            pl.col("prev_t").is_not_null()
            & (pl.col("istzeit_dt") > pl.col("prev_t"))
            & (pl.col("istzeit_dt") <= pl.col("end_t"))
        )
        .select(["Betriebstag", "zn", "istzeit_dt", "netz"])
    )

    # (Sicherheitsgurt) Falls mehrere Transitionen das LU „treffen“, nimm die mit kleinstem end_t
    if not cand.is_empty():
        cand = (
            cand
            .with_columns(pl.col("end_t").rank("dense").over(["Betriebstag","zn","istzeit_dt"]).alias("_rk"))
            .filter(pl.col("_rk") == 1)
            .drop("_rk")
        )

    # 4) Tageszählung HLN vs Fläche
    per_day = (
        cand.group_by(["Betriebstag", "netz"])
            .agg(pl.len().alias("n"))
            .pivot(values="n", index="Betriebstag", columns="netz")
    )

    # 5) fehlende Spalten auffüllen + umbenennen
    if "HLN" not in per_day.columns:
        per_day = per_day.with_columns(pl.lit(0).alias("HLN"))
    if "Flaeche" not in per_day.columns:
        per_day = per_day.with_columns(pl.lit(0).alias("Flaeche"))

    per_day = (
        per_day.rename({"HLN": "LU HLN", "Flaeche": "LU Fläche"})
               .with_columns((pl.col("LU HLN") + pl.col("LU Fläche")).alias("LU alle"))
               .sort("Betriebstag")
    )
    return per_day