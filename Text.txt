def per_train_halte_hln_flaeche(df_ev: pl.DataFrame, trans_inh: pl.DataFrame, *, ontime_sec: int = 360) -> pl.DataFrame:
    ev_sorted = (
        df_ev.sort(["Betriebstag","zn","istzeit_dt"])
             .with_columns([
                 pl.col("bst").shift(1).over(["Betriebstag","zn"]).alias("prev_bst"),
                 pl.col("bst").shift(-1).over(["Betriebstag","zn"]).alias("next_bst"),
             ])
    )

    halts = (
        ev_sorted.filter(pl.col("fsStatus").is_in([1,3]))
                 .select(["Betriebstag","zn","istzeit_dt","vsp","bst","prev_bst","next_bst"])
    )

    if halts.is_empty():
        # Leeres Frame mit kompletter Schemahülle zurückgeben
        return pl.DataFrame(
            schema={
                "Betriebstag": pl.Date,
                "zn": pl.Utf8,
                "Halte HLN": pl.Int64,
                "Halte Fläche": pl.Int64,
                "pü Halte HLN": pl.Int64,
                "pü Halte Fläche": pl.Int64,
                "Halte alle": pl.Int64,
                "pü Halte alle": pl.Int64,
                "PÜ HLN": pl.Float64,
                "PÜ Fläche": pl.Float64,
                "PÜ alle": pl.Float64,
            }
        )

    # normal prev->bst
    h1 = (
        halts.rename({"prev_bst":"u","bst":"v"})
             .join(trans_inh.select(["Betriebstag","zn","u","v","netz_inh"]),
                   on=["Betriebstag","zn","u","v"], how="left")
             .rename({"netz_inh":"netz1"})
    )
    # Startfall bst->next_bst
    h2 = (
        halts.rename({"bst":"u","next_bst":"v"})
             .join(trans_inh.select(["Betriebstag","zn","u","v","netz_inh"]),
                   on=["Betriebstag","zn","u","v"], how="left")
             .rename({"netz_inh":"netz2"})
             .select(["Betriebstag","zn","istzeit_dt","netz2"])
    )

    halts_lab = (
        h1.join(h2, on=["Betriebstag","zn","istzeit_dt"], how="left")
          .with_columns(
              pl.when(pl.col("netz1").is_not_null()).then(pl.col("netz1"))
               .when(pl.col("netz2").is_not_null()).then(pl.col("netz2"))
               .otherwise(pl.lit("Flaeche"))
               .alias("netz_final")
          )
          .with_columns((pl.col("vsp") < ontime_sec).alias("puenktlich"))
          .select(["Betriebstag","zn","netz_final","puenktlich"])
    )

    per_train = (
        halts_lab.group_by(["Betriebstag","zn","netz_final"])
                 .agg([
                     pl.len().alias("Halte"),
                     pl.col("puenktlich").sum().cast(pl.Int64).alias("pü Halte"),
                 ])
                 .pivot(values=["Halte","pü Halte"], index=["Betriebstag","zn"], columns="netz_final")
    )

    # fehlende Netz-Spalten erzwingen
    need_cols = {
        "Halte_HLN": 0, "Halte_Flaeche": 0,
        "pü Halte_HLN": 0, "pü Halte_Flaeche": 0,
    }
    for c, val in need_cols.items():
        if c not in per_train.columns:
            per_train = per_train.with_columns(pl.lit(val).alias(c))

    # umbenennen
    per_train = per_train.rename({
        "Halte_HLN": "Halte HLN",
        "Halte_Flaeche": "Halte Fläche",
        "pü Halte_HLN": "pü Halte HLN",
        "pü Halte_Flaeche": "pü Halte Fläche",
    })

    # Totale & Quoten – jetzt existieren die Basis-Spalten garantiert
    per_train = per_train.with_columns([
        (pl.col("Halte HLN") + pl.col("Halte Fläche")).alias("Halte alle"),
        (pl.col("pü Halte HLN") + pl.col("pü Halte Fläche")).alias("pü Halte alle"),
        pl.when(pl.col("Halte HLN") > 0).then(pl.col("pü Halte HLN")/pl.col("Halte HLN")).otherwise(None).alias("PÜ HLN"),
        pl.when(pl.col("Halte Fläche") > 0).then(pl.col("pü Halte Fläche")/pl.col("Halte Fläche")).otherwise(None).alias("PÜ Fläche"),
        pl.when(pl.col("Halte alle") > 0).then(pl.col("pü Halte alle")/pl.col("Halte alle")).otherwise(None).alias("PÜ alle"),
    ])

    return per_train.sort(["Betriebstag","zn"])



def per_train_metrics(df_ev: pl.DataFrame, seg_edges: pl.DataFrame, *, ontime_sec: int = 360) -> pl.DataFrame:
    trans_inh = build_transitions_with_inherited_net(df_ev, seg_edges, default_first="Flaeche")
    pt_halte = per_train_halte_hln_flaeche(df_ev, trans_inh, ontime_sec=ontime_sec)
    pt_lu = per_train_lu_hln_flaeche_with_uc(df_ev, trans_inh)

    per_train = pt_halte.join(pt_lu, on=["Betriebstag","zn"], how="outer")

    # ALLE erwarteten Spalten robust auffüllen
    must_exist_int0 = [
        "Halte HLN","Halte Fläche","pü Halte HLN","pü Halte Fläche",
        "Halte alle","pü Halte alle",
        "LU HLN","LU Fläche","LU alle",
    ]
    for c in must_exist_int0:
        if c not in per_train.columns:
            per_train = per_train.with_columns(pl.lit(0).alias(c))
        else:
            per_train = per_train.with_columns(pl.col(c).fill_null(0))

    must_exist_float = ["PÜ HLN","PÜ Fläche","PÜ alle"]
    for c in must_exist_float:
        if c not in per_train.columns:
            per_train = per_train.with_columns(pl.lit(None).cast(pl.Float64).alias(c))

    return per_train.sort(["Betriebstag","zn"])