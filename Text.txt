def lu_hln_flaeche_per_day(df_ev: pl.DataFrame, trans_net: pl.DataFrame) -> pl.DataFrame:
    # 1) LU-Events
    df_lu = (
        df_ev.filter(pl.col("uc").is_not_null())
             .select(["Betriebstag", "zn", "istzeit_dt", "uc"])
             .sort(["Betriebstag", "zn", "istzeit_dt"])
    )
    if df_lu.is_empty():
        return (
            df_ev.select("Betriebstag").unique().sort("Betriebstag")
                 .with_columns([
                     pl.lit(0).alias("LU HLN"),
                     pl.lit(0).alias("LU Fläche"),
                     pl.lit(0).alias("LU Unbekannt"),
                     pl.lit(0).alias("LU alle"),
                 ])
        )

    # 2) Transitions: rechtes Zeitende klar benennen
    trans_sorted = (
        trans_net
        .rename({"istzeit_dt": "end_t"})
        .sort(["Betriebstag", "zn", "end_t"])
    )

    # 3a) backward: letzte Transition mit end_t <= LU-Zeit
    lu_bw = (
        df_lu.join_asof(
            trans_sorted,
            left_on="istzeit_dt", right_on="end_t",
            by=["Betriebstag", "zn"],
            strategy="backward",
        )
        # rechte Spalten explizit umbenennen, damit wir stabil darauf zugreifen
        .rename({"prev_t": "prev_t_bw", "end_t": "end_t_bw", "netz": "netz_bw"})
    )
    ok_bw = (pl.col("prev_t_bw").is_not_null()) & (pl.col("istzeit_dt") >= pl.col("prev_t_bw"))

    # 3b) forward: erste Transition mit end_t >= LU-Zeit (für LUs vor der ersten Transition)
    lu_fw = (
        df_lu.join_asof(
            trans_sorted,
            left_on="istzeit_dt", right_on="end_t",
            by=["Betriebstag", "zn"],
            strategy="forward",
        )
        .rename({"prev_t": "prev_t_fw", "end_t": "end_t_fw", "netz": "netz_fw"})
    )
    # gültig, wenn LU-Zeit im Intervall (prev_t_fw, end_t_fw] liegt
    ok_fw = (
        (pl.col("prev_t_fw").is_not_null())
        & (pl.col("istzeit_dt") > pl.col("prev_t_fw"))
        & (pl.col("istzeit_dt") <= pl.col("end_t_fw"))
    )

    # 4) Zusammenführen: backward bevorzugen, sonst forward, sonst Unbekannt
    lu_mapped = (
        lu_bw.join(
            lu_fw.select(["Betriebstag", "zn", "istzeit_dt", "prev_t_fw", "end_t_fw", "netz_fw"]),
            on=["Betriebstag", "zn", "istzeit_dt"],
            how="left",
        )
        .with_columns(
            pl.when(ok_bw).then(pl.col("netz_bw"))
             .when(ok_fw).then(pl.col("netz_fw"))
             .otherwise(pl.lit("Unbekannt"))
             .alias("netz_final")
        )
        .select(["Betriebstag", "zn", "istzeit_dt", "netz_final"])
    )

    # 5) Tagesweise HLN/Fläche/Unbekannt zählen
    per_day = (
        lu_mapped
        .group_by(["Betriebstag", "netz_final"])
        .agg(pl.len().alias("n"))
        .pivot(values="n", index="Betriebstag", columns="netz_final")
    )

    # fehlende Spalten auffüllen + umbenennen
    for k in ["HLN", "Flaeche", "Unbekannt"]:
        if k not in per_day.columns:
            per_day = per_day.with_columns(pl.lit(0).alias(k))

    return (
        per_day.rename({"HLN": "LU HLN", "Flaeche": "LU Fläche", "Unbekannt": "LU Unbekannt"})
               .with_columns((pl.col("LU HLN") + pl.col("LU Fläche") + pl.col("LU Unbekannt")).alias("LU alle"))
               .sort("Betriebstag")
    )