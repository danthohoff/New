def lu_hln_flaeche_per_day_node_based_with_uc(
    df_ev: pl.DataFrame,
    seg_edges: pl.DataFrame,     # ['u','v','netz'] mit HLN/Flaeche (beide Richtungen enthalten)
    *,
    default_to_flaeche: bool = True,
    dedup_key: tuple[str, ...] = ("Betriebstag","zn","istzeit_dt","uc"),
) -> pl.DataFrame:
    """
    Mapt LU (an BST) auf Abschnitt:
      - normal: (prev_bst -> bst)
      - Startfall: (bst -> next_bst), wenn prev_bst fehlt
    Zählt pro Tag HLN/Fläche und pro UC-Kategorie (EIU/EVU/Sekundär/Weitere).
    Liefert zusätzlich LU HLN, LU Fläche, LU alle und LU klassisch (Abgleich).
    """
    # --- klassische Tageszählung (zum Abgleich; gleiche Dedup-Regel) ---
    classic = (
        df_ev.filter(pl.col("uc").is_not_null())
             .select(["Betriebstag","zn","istzeit_dt","uc"])
             .unique(subset=list(dedup_key))
             .group_by("Betriebstag").agg(pl.len().alias("LU klassisch"))
    )

    # --- prev/next je Lauf ---
    ev_sorted = (
        df_ev.sort(["Betriebstag","zn","istzeit_dt"])
             .with_columns([
                 pl.col("bst").shift(1).over(["Betriebstag","zn"]).alias("prev_bst"),
                 pl.col("bst").shift(-1).over(["Betriebstag","zn"]).alias("next_bst"),
             ])
    )

    # --- nur LU-Zeilen, dedupliziert ---
    lu_rows = (
        ev_sorted.filter(pl.col("uc").is_not_null())
                 .select(["Betriebstag","zn","istzeit_dt","uc","bst","prev_bst","next_bst"])
                 .unique(subset=list(dedup_key))
    )
    if lu_rows.is_empty():
        return (
            df_ev.select("Betriebstag").unique().sort("Betriebstag")
                 .with_columns([
                     pl.lit(0).alias("LU HLN"),
                     pl.lit(0).alias("LU Fläche"),
                     pl.lit(0).alias("LU alle"),
                     pl.lit(0).alias("LU klassisch"),
                 ])
        )

    # --- zwei mögliche Kanten-Labels: prev→bst (normal) und bst→next (Startfall) ---
    lu_l1 = (
        lu_rows
        .join(seg_edges, left_on=["prev_bst","bst"], right_on=["u","v"], how="left")
        .rename({"netz":"netz_prev"})
    )
    lu_l2 = (
        lu_l1
        .join(seg_edges, left_on=["bst","next_bst"], right_on=["u","v"], how="left")
        .rename({"netz":"netz_next"})
    )

    # --- Netz final wählen + Kategorie mappen ---
    lu_labeled = (
        lu_l2.with_columns(
            pl.when(pl.col("netz_prev").is_not_null()).then(pl.col("netz_prev"))
             .when(pl.col("netz_next").is_not_null()).then(pl.col("netz_next"))
             .otherwise(pl.lit("Flaeche") if default_to_flaeche else pl.lit("Unbekannt"))
             .alias("netz_final"),
            uc_category_expr("uc"),
        )
        .select(["Betriebstag","zn","istzeit_dt","uc","UC_Kat","netz_final"])
        .unique(subset=["Betriebstag","zn","istzeit_dt","uc"])  # Guard gegen Doppelmatches
    )

    # --- Counts pro Tag × Kategorie × Netz ---
    # Spaltenlabel z. B. "EIU LU HLN", "EVU LU Fläche", ...
    lu_counts = (
        lu_labeled
        .with_columns(pl.concat_str([pl.col("UC_Kat"), pl.lit(" LU "), pl.col("netz_final")]).alias("label"))
        .group_by(["Betriebstag","label"])
        .agg(pl.len().alias("n"))
        .pivot(values="n", index="Betriebstag", columns="label")
    )

    # --- fehlende erwartete Labels auffüllen ---
    cats = ["EIU","EVU","Sekundär","Weitere"]  # „Unbekannt“ wollen wir i. d. R. vermeiden
    nets = ["HLN","Flaeche"]
    expected = [f"{c} LU {n}" for c in cats for n in nets]
    for col in expected:
        if col not in lu_counts.columns:
            lu_counts = lu_counts.with_columns(pl.lit(0).alias(col))

    # --- Gesamtsummen je Netz + alle ---
    per_day = lu_counts
    per_day = per_day.with_columns([
        sum([pl.col(f"{c} LU HLN") for c in cats]).alias("LU HLN"),
        sum([pl.col(f"{c} LU Flaeche") for c in cats]).alias("LU Fläche"),
    ])
    per_day = per_day.with_columns((pl.col("LU HLN") + pl.col("LU Fläche")).alias("LU alle"))

    # --- Abgleich mit klassisch ---
    per_day = (
        per_day.sort("Betriebstag")
               .join(classic, on="Betriebstag", how="left")
               .with_columns(pl.col("LU klassisch").fill_null(0))
    )

    return per_day