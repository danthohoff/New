import polars as pl

def interactions_nrw_at_stations(
    df_zlm: pl.DataFrame,
    nrw_bsts: list[str],
    window_minutes: int = 10,
    split_nrw_state: bool = True,
) -> tuple[pl.DataFrame, pl.DataFrame]:
    """
    Zählt Interaktionen von Zügen an derselben BST innerhalb ±window_minutes.
    Klassifiziert Züge in NRW vs. Nicht-NRW (mind. eine BST ∈ NRW im Zuglauf).
    Optional: teilt gemischte Interaktionen nach NRW-Zug-Status (kommt aus NRW vs. fährt später in NRW).

    Returns:
      per_bst: 1 Zeile je BST mit Interaktions-Zählungen
      pairs:   die gefilterten Paar-Events (Debug/Analyse)
    """

    # --- 1) Basis: Flags pro Event und dynamische NRW-Status (past / future) je Zugverlauf ---
    ev = (
        df_zlm
        .select(["Betriebstag", "zn", "bst", "istzeit_dt"])
        .with_columns([
            pl.col("bst").is_in(nrw_bsts).alias("in_nrw"),
        ])
        .sort(["Betriebstag", "zn", "istzeit_dt"])
        .with_columns([
            # Zug ist NRW-Zug, wenn IRGENDEIN Event in NRW ist
            pl.col("in_nrw").any().over(["Betriebstag", "zn"]).alias("is_nrw_train"),
            # "past": vor diesem Event schon in NRW gewesen?
            pl.col("in_nrw").cum_max().over(["Betriebstag", "zn"]).shift(1).fill_null(False).alias("past_in_nrw"),
            # "future": nach diesem Event irgendwann in NRW?
            pl.col("in_nrw").reverse().cum_max().reverse().over(["Betriebstag", "zn"]).shift(-1).fill_null(False).alias("future_in_nrw"),
        ])
        .with_columns(
            pl.when(pl.col("is_nrw_train")).then(pl.lit("NRW")).otherwise(pl.lit("Nicht-NRW")).alias("train_type")
        )
    )

    # --- 2) Paarbildung: self-join auf (Tag, BST), nur unterschiedliche Züge, Zeitdiff ≤ Fenster ---
    # Hinweis: Wir vermeiden Doppelzählung via zn_left < zn_right
    pairs = (
        ev.join(ev, on=["Betriebstag", "bst"], how="inner", suffix="_r")
          .filter(pl.col("zn") < pl.col("zn_r"))
          .with_columns([
              (pl.col("istzeit_dt") - pl.col("istzeit_dt_r")).abs().alias("dt_diff"),
          ])
          .filter(pl.col("dt_diff") <= pl.duration(minutes=window_minutes))
    )

    # --- 3) Interaktions-Kategorien (stationär, zur Paarzeit) ---
    is_nrw_l = pl.col("train_type")   == "NRW"
    is_nrw_r = pl.col("train_type_r") == "NRW"

    both_nrw = (is_nrw_l & is_nrw_r)
    both_non = (~is_nrw_l & ~is_nrw_r)
    mixed    = (is_nrw_l ^ is_nrw_r)

    # NRW-Zug-Status zum Interaktionszeitpunkt:
    #  - wenn links NRW, nimm left.past/future, sonst right.past/future
    nrw_past   = pl.when(is_nrw_l).then(pl.col("past_in_nrw")).otherwise(pl.col("past_in_nrw_r"))
    nrw_future = pl.when(is_nrw_l).then(pl.col("future_in_nrw")).otherwise(pl.col("future_in_nrw_r"))

    from_nrw    = nrw_past                          # kam vorher schon aus NRW
    enter_later = (~nrw_past) & nrw_future          # war noch nicht in NRW, fährt später rein

    # --- 4) Aggregation pro BST ---
    # Basisspalten
    agg_exprs = [
        both_nrw.sum().alias("inter_NRWs"),
        both_non.sum().alias("inter_NichtNRWs"),
        mixed.sum().alias("inter_gemischt"),
    ]
    if split_nrw_state:
        agg_exprs.extend([
            (mixed & from_nrw).sum().alias("inter_gemischt_fromNRW"),
            (mixed & enter_later).sum().alias("inter_gemischt_enterLater"),
        ])

    per_bst = (
        pairs.group_by(["bst"])
             .agg(agg_exprs)
             .sort("bst")
    )

    return per_bst, pairs