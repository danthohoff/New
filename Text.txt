import polars as pl

# --- UC → Kategorie (ohne "Unbekannt": alles Nicht-EIU/EVU/Sek → "Weitere")
def uc_category_expr(col: str = "uc") -> pl.Expr:
    return (
        pl.when(pl.col(col).is_in([31,32,28,21,22,23,24,25,26,27,29,30,18,12,13,14,47,48,49]))
          .then(pl.lit("EIU"))
        .when(pl.col(col).is_in([62,63,64,69,58,68,51,52,53,54,57,61,59,60]))
          .then(pl.lit("EVU"))
        .when(pl.col(col).is_in([91,92,93,94,95]))
          .then(pl.lit("Sekundär"))
        .otherwise(pl.lit("Weitere"))
        .alias("UC_Kat")
    )
)

# 1) Kanten-Segmentierung (u,v) → netz  laden; beide Richtungen!
def load_network_segmentation(csv_path: str | pl.Path) -> pl.DataFrame:
    seg = (
        pl.read_csv(csv_path)
        .select(["VonBetriebsstelle","BisBetriebsstelle","Segmentierung2025"])
        .with_columns([
            pl.col("VonBetriebsstelle").cast(pl.Utf8).alias("von"),
            pl.col("BisBetriebsstelle").cast(pl.Utf8).alias("bis"),
            pl.col("Segmentierung2025").cast(pl.Utf8).str.to_uppercase().alias("seg_raw"),
        ])
        .with_columns(
            pl.when(pl.col("seg_raw") == "HLN").then(pl.lit("HLN"))
             .otherwise(pl.lit("Flaeche")).alias("netz")
        )
    )
    fwd = seg.select([pl.col("von").alias("u"), pl.col("bis").alias("v"), pl.col("netz")])
    rev = seg.select([pl.col("bis").alias("u"), pl.col("von").alias("v"), pl.col("netz")])
    return pl.concat([fwd, rev]).unique(subset=["u","v"])

# 2) Transitions pro Zuglauf + „Vorwärts-Erbe“ für unbekannte Netze
def build_transitions_with_inherited_net(
    df_ev: pl.DataFrame,
    seg_edges: pl.DataFrame,
    *,
    default_first: str = "Flaeche",  # falls die ERSTE Kante unbekannt ist
) -> pl.DataFrame:
    """
    Erzeugt je (Betriebstag, zn) die Folge-Abschnitte u->v mit Zeiten und
    glättet das Netz-Label: unbekannt erbt vom vorherigen bekannten Segment.
    Rückgabe: ['Betriebstag','zn','u','v','start_t','end_t','netz_inh']
    """
    trans = (
        df_ev.sort(["Betriebstag","zn","istzeit_dt"])
             .with_columns([
                 pl.col("bst").shift(1).over(["Betriebstag","zn"]).alias("u"),
                 pl.col("istzeit_dt").shift(1).over(["Betriebstag","zn"]).alias("start_t"),
                 pl.col("bst").alias("v"),
                 pl.col("istzeit_dt").alias("end_t"),
             ])
             .filter(pl.col("u").is_not_null())
             .select(["Betriebstag","zn","u","v","start_t","end_t"])
             .join(seg_edges, on=["u","v"], how="left")              # -> 'netz' (kann null sein)
             .with_columns(pl.col("netz").alias("netz0"))
             .drop("netz")
             # wichtig: pro Lauf in Zeitfolge vorwärts auffüllen
             .with_columns(
                 pl.col("netz0").fill_null(strategy="forward").over(["Betriebstag","zn"]).alias("netz_ffill")
             )
             # leading nulls (wenn erste Kante unbekannt) auf default setzen
             .with_columns(
                 pl.when(pl.col("netz_ffill").is_null()).then(pl.lit(default_first)).otherwise(pl.col("netz_ffill")).alias("netz_inh")
             )
             .select(["Betriebstag","zn","u","v","start_t","end_t","netz_inh"])
    )
    # Falls derselbe Abschnitt mehrfach vorkommt: wir brauchen nur die letzte Klassifizierung pro end_t
    return trans.sort(["Betriebstag","zn","end_t"]).unique(subset=["Betriebstag","zn","u","v","end_t"], keep="last")

# 3) LU node-basiert + geerbtes Netz + UC-Kategorien
def lu_hln_flaeche_per_day_node_based_with_uc_inherit(
    df_ev: pl.DataFrame,
    trans_inh: pl.DataFrame,     # aus build_transitions_with_inherited_net
    *,
    dedup_key: tuple[str, ...] = ("Betriebstag","zn","istzeit_dt","uc"),
) -> pl.DataFrame:
    """
    Mapt LU an BST auf Abschnitt:
      normal: (prev_bst -> bst)
      Startfall: (bst -> next_bst), falls prev_bst fehlt
    nimmt dabei 'netz_inh' (HLN/Fläche) aus den geglätteten Transitions.
    zählt Tageswerte je Kategorie×Netz + Gesamtsummen.
    """
    # klassische Tageszählung (zum Konsistenzcheck)
    classic = (
        df_ev.filter(pl.col("uc").is_not_null())
             .select(["Betriebstag","zn","istzeit_dt","uc"])
             .unique(subset=list(dedup_key))
             .group_by("Betriebstag").agg(pl.len().alias("LU klassisch"))
    )

    ev_sorted = (
        df_ev.sort(["Betriebstag","zn","istzeit_dt"])
             .with_columns([
                 pl.col("bst").shift(1).over(["Betriebstag","zn"]).alias("prev_bst"),
                 pl.col("bst").shift(-1).over(["Betriebstag","zn"]).alias("next_bst"),
             ])
    )

    lu_rows = (
        ev_sorted.filter(pl.col("uc").is_not_null())
                 .select(["Betriebstag","zn","istzeit_dt","uc","bst","prev_bst","next_bst"])
                 .unique(subset=list(dedup_key))
    )
    if lu_rows.is_empty():
        return df_ev.select("Betriebstag").unique().sort("Betriebstag").with_columns([
            pl.lit(0).alias("LU HLN"), pl.lit(0).alias("LU Fläche"), pl.lit(0).alias("LU alle"), pl.lit(0).alias("LU klassisch")
        ])

    # Join auf Transitions mit ererbtem Netz:
    #  a) normal prev->bst
    l1 = (
        lu_rows.rename({"prev_bst":"u","bst":"v"})
               .join(trans_inh.select(["Betriebstag","zn","u","v","netz_inh"]),
                     on=["Betriebstag","zn","u","v"], how="left")
               .rename({"netz_inh":"netz1"})
    )
    #  b) Startfall bst->next
    l2 = (
        lu_rows.rename({"bst":"u","next_bst":"v"})
               .join(trans_inh.select(["Betriebstag","zn","u","v","netz_inh"]),
                     on=["Betriebstag","zn","u","v"], how="left")
               .rename({"netz_inh":"netz2"})
               .select(["Betriebstag","zn","istzeit_dt","uc","netz2"])
    )

    lu_lab = (
        l1.join(l2, on=["Betriebstag","zn","istzeit_dt","uc"], how="left")
          .with_columns([
              # bevorzugt normal, sonst Startfall; es bleibt nur HLN/Fläche, da trans_inh so geglättet wurde
              pl.when(pl.col("netz1").is_not_null()).then(pl.col("netz1"))
               .when(pl.col("netz2").is_not_null()).then(pl.col("netz2"))
               .otherwise(pl.lit("Flaeche"))  # sollte kaum vorkommen
               .alias("netz_final"),
          ])
          .with_columns(uc_category_expr("uc"))
          .select(["Betriebstag","zn","istzeit_dt","uc","UC_Kat","netz_final"])
          .unique(subset=["Betriebstag","zn","istzeit_dt","uc"])
    )

    # Tages-Counts je Kategorie×Netz
    lu_counts = (
        lu_lab.with_columns(pl.concat_str([pl.col("UC_Kat"), pl.lit(" LU "), pl.col("netz_final")]).alias("label"))
              .group_by(["Betriebstag","label"]).agg(pl.len().alias("n"))
              .pivot(values="n", index="Betriebstag", columns="label")
    )

    cats = ["EIU","EVU","Sekundär","Weitere"]; nets = ["HLN","Flaeche"]
    expected = [f"{c} LU {n}" for c in cats for n in nets]
    for col in expected:
        if col not in lu_counts.columns:
            lu_counts = lu_counts.with_columns(pl.lit(0).alias(col))

    per_day = lu_counts.with_columns([
        sum([pl.col(f"{c} LU HLN") for c in cats]).alias("LU HLN"),
        sum([pl.col(f"{c} LU Flaeche") for c in cats]).alias("LU Fläche"),
    ]).with_columns((pl.col("LU HLN") + pl.col("LU Fläche")).alias("LU alle")) \
      .sort("Betriebstag") \
      .join(classic, on="Betriebstag", how="left") \
      .with_columns(pl.col("LU klassisch").fill_null(0))

    return per_day

# 4) Halte & pünktliche Halte nach HLN/FLN (gleiche Erb-Logik)
def halte_hln_flaeche_per_day(
    df_ev: pl.DataFrame,
    trans_inh: pl.DataFrame,
    *,
    ontime_sec: int = 360,
) -> pl.DataFrame:
    """
    Ordnet jeden Halt (fsStatus ∈ {1,3}) der Abschnitts-Klasse (HLN/Fläche) zu:
      normal: (prev_bst -> bst)
      Startfall: (bst -> next_bst), falls prev_bst fehlt
    und aggregiert pro Tag: Halte HLN/FLN, pü Halte HLN/FLN.
    """
    ev_sorted = (
        df_ev.sort(["Betriebstag","zn","istzeit_dt"])
             .with_columns([
                 pl.col("bst").shift(1).over(["Betriebstag","zn"]).alias("prev_bst"),
                 pl.col("bst").shift(-1).over(["Betriebstag","zn"]).alias("next_bst"),
             ])
    )

    halts = (
        ev_sorted.filter(pl.col("fsStatus").is_in([1,3]))
                 .select(["Betriebstag","zn","istzeit_dt","vsp","bst","prev_bst","next_bst"])
    )

    # normal prev->bst
    h1 = (
        halts.rename({"prev_bst":"u","bst":"v"})
             .join(trans_inh.select(["Betriebstag","zn","u","v","netz_inh"]),
                   on=["Betriebstag","zn","u","v"], how="left")
             .rename({"netz_inh":"netz1"})
    )
    # Startfall bst->next_bst
    h2 = (
        halts.rename({"bst":"u","next_bst":"v"})
             .join(trans_inh.select(["Betriebstag","zn","u","v","netz_inh"]),
                   on=["Betriebstag","zn","u","v"], how="left")
             .rename({"netz_inh":"netz2"})
             .select(["Betriebstag","zn","istzeit_dt","netz2"])
    )

    halts_lab = (
        h1.join(h2, on=["Betriebstag","zn","istzeit_dt"], how="left")
          .with_columns(
              pl.when(pl.col("netz1").is_not_null()).then(pl.col("netz1"))
               .when(pl.col("netz2").is_not_null()).then(pl.col("netz2"))
               .otherwise(pl.lit("Flaeche"))
               .alias("netz_final")
          )
          .with_columns((pl.col("vsp") < ontime_sec).alias("puenktlich"))
          .select(["Betriebstag","netz_final","puenktlich"])
    )

    per_day = (
        halts_lab.group_by(["Betriebstag","netz_final"])
                 .agg([
                     pl.len().alias("Halte"),
                     pl.col("puenktlich").sum().cast(pl.Int64).alias("pü Halte"),
                 ])
                 .pivot(values=["Halte","pü Halte"], index="Betriebstag", columns="netz_final")
    )

    # Spalten sicherstellen & umbenennen
    for base in ["Halte","pü Halte"]:
        for n in ["HLN","Flaeche"]:
            col = f"{base}_{n}"
            if col not in per_day.columns:
                per_day = per_day.with_columns(pl.lit(0).alias(col))

    per_day = per_day.rename({
        "Halte_HLN":"Halte HLN", "Halte_Flaeche":"Halte Fläche",
        "pü Halte_HLN":"pü Halte HLN", "pü Halte_Flaeche":"pü Halte Fläche",
    }).sort("Betriebstag")

    return per_day