import polars as pl
import numpy as np
import matplotlib.pyplot as plt

def startdelay_bins_with_punct(
    df_zlm: pl.DataFrame,
    *,
    bin_size_sec: int = 30,
    max_delay_min: int = 30,
    only_after_start: bool = True,
    filter_bsts: list[str] | None = None,
    min_halts_per_train: int = 1,
):
    df = df_zlm
    if filter_bsts:
        df = df.filter(pl.col("bst").is_in(filter_bsts))

    # Start je (Tag,Zug)
    starts = (
        df.filter(pl.col("fsStatus") == 2)
          .select(["Betriebstag","zn","istzeit_dt","vsp"])
          .rename({"istzeit_dt":"start_time", "vsp":"vsp_start"})
          .sort(["Betriebstag","zn","start_time"])
          .group_by(["Betriebstag","zn"])
          .agg([
              pl.first("start_time").alias("start_time"),
              pl.first("vsp_start").alias("vsp_start"),
          ])
    )

    # Halte
    halts = (
        df.filter(pl.col("fsStatus").is_in([1,3]))
          .select(["Betriebstag","zn","istzeit_dt","vsp"])
          .unique(subset=["Betriebstag","zn","istzeit_dt"])
          .with_columns((pl.col("vsp") < 360).alias("halt_punct"))
    )

    # Halte an Start joinen
    halts_join = halts.join(starts, on=["Betriebstag","zn"], how="inner")
    if only_after_start:
        halts_join = halts_join.filter(pl.col("istzeit_dt") >= pl.col("start_time"))

    # pro Zug
    per_train = (
        halts_join
        .group_by(["Betriebstag","zn","start_time","vsp_start"])
        .agg([
            pl.len().alias("halte"),
            pl.sum("halt_punct").alias("halte_puenktlich"),
        ])
        .with_columns((pl.col("halte_puenktlich") / pl.col("halte")).alias("punct_rate"))
        .filter(pl.col("halte") >= min_halts_per_train)
    )

    # Binning
    max_delay_sec = max_delay_min * 60
    per_train = per_train.filter(pl.col("vsp_start").abs() <= max_delay_sec)
    per_train = per_train.with_columns([
        ((pl.col("vsp_start") + max_delay_sec) // bin_size_sec).cast(pl.Int64).alias("bin_idx"),
        (pl.col("bin_idx") * bin_size_sec - max_delay_sec).alias("bin_start_s"),
        (pl.col("bin_idx") * bin_size_sec - max_delay_sec + bin_size_sec).alias("bin_end_s"),
    ])

    # je Bin: Anzahl, Mean/Median, Std/SE, IQR
    per_bin = (
        per_train
        .group_by(["bin_idx","bin_start_s","bin_end_s"])
        .agg([
            pl.len().alias("n_zuege"),
            pl.median("punct_rate").alias("punct_rate_median"),
            pl.mean("punct_rate").alias("punct_rate_mean"),
            pl.std("punct_rate").alias("punct_rate_std"),
            (pl.std("punct_rate") / (pl.count().cast(pl.Float64).pow(0.5))).alias("punct_rate_se"),
            pl.quantile("punct_rate", 0.25, interpolation="nearest").alias("punct_rate_q25"),
            pl.quantile("punct_rate", 0.75, interpolation="nearest").alias("punct_rate_q75"),
            pl.median("vsp_start").alias("vsp_start_median"),
            pl.mean("vsp_start").alias("vsp_start_mean"),
        ])
        .sort("bin_idx")
    )
    return per_bin, per_train


def plot_startdelay_bin_summary_clean(
    per_bin: pl.DataFrame,
    *,
    metric: str = "mean",            # "mean" (Default) oder "median"
    show_band: bool = True,          # Fehlerband zeigen (±Std bei mean, IQR bei median)
    show_errorbars: bool = False,    # nur bei metric="mean": SE-Fehlerbalken
    min_points_for_marker: int = 30,
    figsize=(11,5),
):
    metric = metric.lower()
    assert metric in {"mean","median"}, "metric must be 'mean' or 'median'"

    x_left  = per_bin["bin_start_s"].to_numpy()
    width   = (per_bin["bin_end_s"] - per_bin["bin_start_s"]).to_numpy()
    n       = per_bin["n_zuege"].to_numpy()
    x_mid   = x_left + width/2

    if metric == "mean":
        y = (per_bin["punct_rate_mean"] * 100).to_numpy()
        std = (per_bin["punct_rate_std"] * 100).to_numpy()
        se  = (per_bin["punct_rate_se"] * 100).to_numpy()
        label_pts = "Pünktlichkeitsquote (Mittelwert)"
    else:
        y = (per_bin["punct_rate_median"] * 100).to_numpy()
        q25 = (per_bin["punct_rate_q25"] * 100).to_numpy()
        q75 = (per_bin["punct_rate_q75"] * 100).to_numpy()
        label_pts = "Pünktlichkeitsquote (Median)"

    mask = (n >= min_points_for_marker) & ~np.isnan(y)
    x_pts, y_pts = x_mid[mask], y[mask]

    fig, ax1 = plt.subplots(figsize=figsize)
    ax1.bar(x_left, n, width=width, align="edge", alpha=0.6, edgecolor="white")
    ax1.set_xlabel("Startverspätung (Sekunden)")
    ax1.set_ylabel("Anzahl Züge je Bin")

    ax2 = ax1.twinx()
    if x_pts.size > 0:
        ax2.scatter(x_pts, y_pts, s=22, marker="o", alpha=0.9, label=label_pts)

        if show_band:
            if metric == "mean":
                # ±1 Std-Abw.
                std_pts = std[mask]
                ax2.fill_between(x_pts, y_pts - std_pts, y_pts + std_pts, alpha=0.15, linewidth=0, label="±1σ")
            else:
                # IQR-Band (Q25..Q75)
                q25_pts = q25[mask]; q75_pts = q75[mask]
                ax2.fill_between(x_pts, q25_pts, q75_pts, alpha=0.15, linewidth=0, label="IQR (Q25–Q75)")

        if show_errorbars and metric == "mean":
            se_pts = se[mask]
            ax2.errorbar(x_pts, y_pts, yerr=se_pts, fmt="none", alpha=0.8, linewidth=1)

    ax2.set_ylabel("Pünktlichkeitsquote [%]")
    ax2.set_ylim(0, 100)
    ax2.legend(loc="upper right")
    ax1.grid(alpha=0.25)
    plt.tight_layout()
    plt.show()


# Aggregation (optional mit BST-Filter)
per_bin, per_train = startdelay_bins_with_punct(
    df_zlm,
    bin_size_sec=30,
    max_delay_min=30,
    only_after_start=True,
    filter_bsts=["K", "D", "DO"],   # oder None für alle
    min_halts_per_train=2,
)

# Plot: Default = Mittelwert mit Std-Band (und optional SE-Balken)
plot_startdelay_bin_summary_clean(
    per_bin,
    metric="mean",          # oder "median"
    show_band=True,
    show_errorbars=False,   # bei mean → SE-Balken
    min_points_for_marker=50,
)
