import polars as pl
import numpy as np
import matplotlib.pyplot as plt

def startdelay_bins_with_punct(
    df_zlm: pl.DataFrame,
    *,
    bin_size_sec: int = 30,
    max_delay_min: int = 30,
    only_after_start: bool = True,          # nur Halte NACH Start berücksichtigen
    filter_bsts: list[str] | None = None,   # Liste von BSTs; None = alle
    min_halts_per_train: int = 1,           # Mindesthalte je Zug für stabile punct_rate
):
    """
    Liefert:
      per_bin: je Startverspätungs-Bin Aggregation (Anzahl, Median/Mean, Std, SE)
      per_train: pro (Tag,Zug) Kennzahlen (start_time, vsp_start, halte, punct_rate)

    Erwartete Spalten in df_zlm:
      'Betriebstag' (date), 'zn', 'bst', 'istzeit_dt' (datetime), 'fsStatus' (int), 'vsp' (sec)
    """

    df = df_zlm
    if filter_bsts is not None and len(filter_bsts) > 0:
        df = df.filter(pl.col("bst").is_in(filter_bsts))

    # --- Start-Ereignisse je (Tag,Zug) ---
    starts = (
        df.filter(pl.col("fsStatus") == 2)
          .select(["Betriebstag","zn","istzeit_dt","vsp"])
          .rename({"istzeit_dt":"start_time", "vsp":"vsp_start"})
          .sort(["Betriebstag","zn","start_time"])
          .group_by(["Betriebstag","zn"])
          .agg([
              pl.first("start_time").alias("start_time"),
              pl.first("vsp_start").alias("vsp_start"),
          ])
    )

    # --- Halte (fsStatus 1/3) ---
    halts = (
        df.filter(pl.col("fsStatus").is_in([1,3]))
          .select(["Betriebstag","zn","istzeit_dt","vsp"])
          .unique(subset=["Betriebstag","zn","istzeit_dt"])
          .with_columns((pl.col("vsp") < 360).alias("halt_punct"))
    )

    # --- Halte an Start joinen und optional nach Start filtern ---
    halts_join = halts.join(starts, on=["Betriebstag","zn"], how="inner")
    if only_after_start:
        halts_join = halts_join.filter(pl.col("istzeit_dt") >= pl.col("start_time"))

    # --- pro Zug: Halte & Pünktlichkeitsquote ---
    per_train = (
        halts_join
        .group_by(["Betriebstag","zn","start_time","vsp_start"])
        .agg([
            pl.len().alias("halte"),
            pl.sum("halt_punct").alias("halte_puenktlich"),
        ])
        .with_columns(
            (pl.col("halte_puenktlich") / pl.col("halte")).alias("punct_rate")
        )
        .filter(pl.col("halte") >= min_halts_per_train)  # Stabilität
    )

    # --- Binning der Startverspätung ---
    max_delay_sec = max_delay_min * 60
    per_train = per_train.filter(pl.col("vsp_start").abs() <= max_delay_sec)

    per_train = per_train.with_columns([
        ((pl.col("vsp_start") + max_delay_sec) // bin_size_sec).cast(pl.Int64).alias("bin_idx"),
    ]).with_columns([
        (pl.col("bin_idx") * bin_size_sec - max_delay_sec).alias("bin_start_s"),
        (pl.col("bin_idx") * bin_size_sec - max_delay_sec + bin_size_sec).alias("bin_end_s"),
    ])

    # --- Aggregation je Bin: Anzahl, Median/Mean, Std, SE ---
    per_bin = (
        per_train
        .group_by(["bin_idx","bin_start_s","bin_end_s"])
        .agg([
            pl.len().alias("n_zuege"),
            pl.median("punct_rate").alias("punct_rate_median"),
            pl.mean("punct_rate").alias("punct_rate_mean"),
            pl.std("punct_rate").alias("punct_rate_std"),   # Streuung der Zug-Quoten im Bin
            # Standardfehler des Mittels:
            (pl.std("punct_rate") / pl.sqrt(pl.count())).alias("punct_rate_se"),
            pl.median("vsp_start").alias("vsp_start_median"),
            pl.mean("vsp_start").alias("vsp_start_mean"),
        ])
        .sort("bin_idx")
    )

    return per_bin, per_train



def plot_startdelay_bin_summary_clean(
    per_bin: pl.DataFrame,
    *,
    use_mean: bool = False,          # False=Median, True=Mean
    show_std_band: bool = True,      # ±1σ als Band
    show_errorbars: bool = False,    # Fehlerbalken (SE) statt Band
    min_points_for_marker: int = 30, # Punkte nur ab so vielen Zügen im Bin
    figsize=(11,5),
):
    # --- Daten vorbereiten ---
    x_left  = per_bin["bin_start_s"].to_numpy()
    width   = (per_bin["bin_end_s"] - per_bin["bin_start_s"]).to_numpy()
    n       = per_bin["n_zuege"].to_numpy()

    x_mid   = x_left + width / 2.0

    if use_mean:
        y_pct = (per_bin["punct_rate_mean"] * 100).to_numpy()
        y_std = (per_bin["punct_rate_std"] * 100).to_numpy()
        y_se  = (per_bin["punct_rate_se"] * 100).to_numpy()
        label_pts = "Pünktlichkeitsquote (Mittelwert)"
    else:
        y_pct = (per_bin["punct_rate_median"] * 100).to_numpy()
        # Für Median gibt es kein „Std“; wir zeigen optional trotzdem Std der Einzel-Züge im Bin
        y_std = (per_bin["punct_rate_std"] * 100).to_numpy()
        y_se  = (per_bin["punct_rate_se"] * 100).to_numpy()
        label_pts = "Pünktlichkeitsquote (Median)"

    mask_pts = (n >= min_points_for_marker) & ~np.isnan(y_pct)
    x_pts, y_pts = x_mid[mask_pts], y_pct[mask_pts]
    std_pts, se_pts = (y_std[mask_pts] if y_std is not None else None,
                       y_se[mask_pts] if y_se is not None else None)

    # --- Plot ---
    fig, ax1 = plt.subplots(figsize=figsize)

    # Bars: Anzahl Züge je Bin
    ax1.bar(x_left, n, width=width, align="edge", alpha=0.6, edgecolor="white")
    ax1.set_xlabel("Startverspätung (Sekunden)")
    ax1.set_ylabel("Anzahl Züge je Bin")

    # Punkte/Band: Pünktlichkeitsquote
    ax2 = ax1.twinx()
    if x_pts.size > 0:
        ax2.scatter(x_pts, y_pts, s=22, marker="o", alpha=0.9, label=label_pts)

        if show_errorbars and se_pts is not None:
            ax2.errorbar(x_pts, y_pts, yerr=se_pts, fmt="none", alpha=0.8, linewidth=1)

        if show_std_band and std_pts is not None:
            ax2.fill_between(x_pts, y_pts - std_pts, y_pts + std_pts,
                             alpha=0.15, linewidth=0, label="±1σ (Std. Abw.)")

    ax2.set_ylabel("Pünktlichkeitsquote [%]")
    ax2.set_ylim(0, 100)
    ax2.legend(loc="upper right")
    ax1.grid(alpha=0.25)
    fig.tight_layout()
    plt.show()


# Beispiel: nur bestimmte Betriebsstellen betrachten
bsts = ["K", "D", "DO"]  # oder jede Liste deiner Wahl

per_bin, per_train = startdelay_bins_with_punct(
    df_zlm,
    bin_size_sec=30,
    max_delay_min=30,
    only_after_start=True,
    filter_bsts=bsts,
    min_halts_per_train=2,
)

# Plot mit Median + ±1σ-Band, Marker erst ab 50 Zügen pro Bin
plot_startdelay_bin_summary_clean(
    per_bin,
    use_mean=False,           # Median
    show_std_band=True,       # ±1σ Band
    show_errorbars=False,     # alternativ: True für SE-Balken
    min_points_for_marker=50,
)