import polars as pl
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os

def startdelay_pertrain_export(
    df_zlm: pl.DataFrame,
    output_csv: str,
    *,
    filter_bsts=None,
    filter_zns=None,
    only_after_start=True,
):
    df = df_zlm

    if filter_bsts:
        df = df.filter(pl.col("bst").is_in(filter_bsts))
    if filter_zns:
        df = df.filter(pl.col("zn").cast(pl.Utf8).is_in([str(z) for z in filter_zns]))

    starts = (
        df.filter(pl.col("fsStatus") == 2)
          .select(["Betriebstag","zn","istzeit_dt","vsp"])
          .rename({"istzeit_dt":"start_time","vsp":"vsp_start"})
          .group_by(["Betriebstag","zn"])
          .agg([
              pl.first("start_time").alias("start_time"),
              pl.first("vsp_start").alias("vsp_start"),
          ])
    )

    halts = (
        df.filter(pl.col("fsStatus").is_in([1,3]))
          .select(["Betriebstag","zn","istzeit_dt","vsp"])
          .with_columns((pl.col("vsp") < 360).alias("halt_punct"))
    )

    halts_join = halts.join(starts, on=["Betriebstag","zn"], how="inner")
    if only_after_start:
        halts_join = halts_join.filter(pl.col("istzeit_dt") >= pl.col("start_time"))

    per_train = (
        halts_join
        .group_by(["Betriebstag","zn","vsp_start"])
        .agg([
            pl.len().alias("halte"),
            pl.sum("halt_punct").alias("halte_puenktlich"),
        ])
        .with_columns((pl.col("halte_puenktlich") / pl.col("halte")).alias("punct_rate"))
        .sort(["Betriebstag","zn"])
    )

    per_train.write_csv(output_csv)
    print(f"✅ CSV gespeichert: {os.path.abspath(output_csv)}")
    return per_train


def plot_boxplots_punct_by_startdelay(per_train: pl.DataFrame, bin_size_sec=30, max_delay_min=30):
    max_delay_sec = max_delay_min * 60
    df = (
        per_train.filter(pl.col("vsp_start").abs() <= max_delay_sec)
                 .with_columns(((pl.col("vsp_start")+max_delay_sec)//bin_size_sec*bin_size_sec - max_delay_sec)
                               .alias("bin_start_s"))
                 .select(["bin_start_s","punct_rate"])
                 .to_pandas()
    )
    df["bin_label"] = (df["bin_start_s"]/60).astype(int)  # Minuten
    plt.figure(figsize=(12,6))
    sns.boxplot(x="bin_label", y="punct_rate", data=df, color="skyblue", fliersize=1)
    plt.xlabel("Startverspätung (Minuten)")
    plt.ylabel("Pünktlichkeitsquote")
    plt.title("Boxplots der Pünktlichkeitsverteilung je Startverspätung")
    plt.grid(alpha=0.3)
    plt.show()


def plot_conditional_heatmap(per_train: pl.DataFrame, bin_size_sec=30, max_delay_min=30, punct_bins=20):
    max_delay_sec = max_delay_min * 60
    df = (
        per_train.filter(pl.col("vsp_start").abs() <= max_delay_sec)
                 .select(["vsp_start","punct_rate"])
                 .to_pandas()
    )

    # 2D-Histogramm: Startverspätung × Pünktlichkeit
    delay_edges = np.arange(-max_delay_sec, max_delay_sec+bin_size_sec, bin_size_sec)
    punct_edges = np.linspace(0, 1, punct_bins+1)
    H, xedges, yedges = np.histogram2d(
        df["vsp_start"], df["punct_rate"], bins=[delay_edges, punct_edges]
    )

    # bedingte Verteilung normalisieren: jede Spalte = p(pünktlich | delay)
    H_cond = (H.T / (H.sum(axis=1) + 1e-9)).T  # (Zeilen=delay, Spalten=punct)

    plt.figure(figsize=(12,6))
    sns.heatmap(
        H_cond.T, cmap="viridis", cbar_kws={"label":"p(Pünktlichkeit | Startverspätung)"},
        xticklabels=(xedges[:-1]/60).astype(int), yticklabels=np.round(yedges[:-1],2)
    )
    plt.xlabel("Startverspätung (Minuten)")
    plt.ylabel("Pünktlichkeitsrate")
    plt.title("Bedingte Verteilung p(Pünktlichkeit | Startverspätung)")
    plt.tight_layout()
    plt.show()


per_train = startdelay_pertrain_export(df_zlm, "zugstart_puenktlichkeit.csv")

# Boxplots
plot_boxplots_punct_by_startdelay(per_train, bin_size_sec=30, max_delay_min=30)

# Bedingte Verteilung (Heatmap)
plot_conditional_heatmap(per_train, bin_size_sec=30, max_delay_min=30, punct_bins=20)