import polars as pl

def lu_hln_flaeche_per_day_node_based(
    df_ev: pl.DataFrame,
    seg_edges: pl.DataFrame,
    *,
    default_to_flaeche: bool = True,
    dedup_key: tuple[str, ...] = ("Betriebstag", "zn", "istzeit_dt", "uc"),
) -> pl.DataFrame:
    """
    Node-basierte Zuordnung: LU an bst -> Abschnitt (prev_bst -> bst).
    seg_edges erwartet Spalten ['u','v','netz'] (HLN/Flaeche), in BEIDEN Richtungen.
    """

    # 0) Klassische LU-Tageszählung (zum späteren Vergleich; gleiche Deduplizierung!)
    classic = (
        df_ev.filter(pl.col("uc").is_not_null())
             .select(["Betriebstag","zn","istzeit_dt","uc"])
             .unique(subset=list(dedup_key))
             .group_by("Betriebstag").agg(pl.len().alias("LU klassisch"))
    )

    # 1) Chronologische Sortierung & prev_bst je Zuglauf
    ev_sorted = (
        df_ev.sort(["Betriebstag","zn","istzeit_dt"])
             .with_columns([
                 pl.col("bst").shift(1).over(["Betriebstag","zn"]).alias("prev_bst"),
             ])
    )

    # 2) Nur LU-Zeilen, dedupliziert wie "klassisch"
    lu_rows = (
        ev_sorted.filter(pl.col("uc").is_not_null())
                 .select(["Betriebstag","zn","istzeit_dt","uc","bst","prev_bst"])
                 .unique(subset=list(dedup_key))
    )

    # 3) Fälle ohne prev_bst (LU am ersten Event des Zuglaufs) – optional als Unknown zählen/wegfiltern
    lu_rows_valid = lu_rows.filter(pl.col("prev_bst").is_not_null())

    # 4) Netz-Zuordnung über (prev_bst -> bst)
    lu_labeled = (
        lu_rows_valid
        .rename({"prev_bst":"u", "bst":"v"})
        .join(seg_edges, on=["u","v"], how="left")
        .with_columns(
            (pl.lit("Flaeche") if default_to_flaeche else pl.lit("Unbekannt"))
            .where(pl.col("netz").is_null())
            .otherwise(pl.col("netz"))
            .alias("netz_final")
        )
        .select(["Betriebstag","zn","istzeit_dt","uc","netz_final"])
    )

    # 5) Tagesweise aggregieren
    per_day = (
        lu_labeled.group_by(["Betriebstag","netz_final"])
                  .agg(pl.len().alias("n"))
                  .pivot(values="n", index="Betriebstag", columns="netz_final")
    )

    # 6) Spalten sicherstellen & umbenennen
    for k in ["HLN","Flaeche","Unbekannt"]:
        if k not in per_day.columns:
            per_day = per_day.with_columns(pl.lit(0).alias(k))

    per_day = (
        per_day.rename({"HLN":"LU HLN", "Flaeche":"LU Fläche", "Unbekannt":"LU Unbekannt"})
               .with_columns((pl.col("LU HLN") + pl.col("LU Fläche") + pl.col("LU Unbekannt")).alias("LU alle"))
               .sort("Betriebstag")
    )

    # 7) Konsistenzcheck mit der klassischen Zählung (gleiche Dedup-Logik!)
    per_day = (
        per_day.join(classic, on="Betriebstag", how="left")
               .with_columns(pl.col("LU klassisch").fill_null(0))
               # Optional: Delta anzeigen, um Differenzen sofort zu sehen
               # .with_columns((pl.col("LU alle") - pl.col("LU klassisch")).alias("Delta"))
    )

    return per_day